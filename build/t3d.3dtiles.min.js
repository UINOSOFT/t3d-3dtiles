// t3d-3dtiles
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("t3d")):"function"==typeof define&&define.amd?define(["exports","t3d"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).t3d=e.t3d||{},e.t3d)}(this,(function(e,t){"use strict";const r=e=>{let t;try{t=new URL(e,"http://fakehost.com/")}catch(e){return null}const r=t.pathname.split("/").pop(),s=r.lastIndexOf(".");if(-1===s||s===r.length-1)return null;return r.substring(s+1)},s=(e,t=null,r=null,n=null,o=0)=>{if(t&&t(e,n,o))return void(r&&r(e,n,o));const a=e.children;for(let n=0,i=a.length;n<i;n++)s(a[n],t,r,e,o+1);r&&r(e,n,o)},n=(e,t,r,s,o=null)=>{const{activeTiles:a}=t,d=e.cached.boundingVolume;if(null===o&&(o=c,l.copy(t.worldMatrix).inverse(),o.copy(r).applyMatrix4(l)),!e.__used||!d.intersectsRay(o))return;a.has(e)&&i(e,r,s);const u=e.children;for(let e=0,a=u.length;e<a;e++)n(u[e],t,r,s,o)},o=(e,t,r,s=null)=>{const{activeTiles:n}=t;null===s&&(s=c,l.copy(t.worldMatrix).inverse(),s.copy(r).applyMatrix4(l));const h=[],m=e.children;for(let e=0,n=m.length;e<n;e++){const n=m[e];if(!n.__used)continue;n.cached.boundingVolume.intersectRay(s,d)&&(d.applyMatrix4(t.worldMatrix),h.push({distance:d.distanceToSquared(r.origin),tile:n}))}h.sort(a);let f=null,p=1/0;if(n.has(e)&&(i(e,r,u),u.length>0)){u.length>1&&u.sort(a);const e=u[0];u.length=0,f=e,p=e.distance*e.distance}for(let e=0,n=h.length;e<n;e++){const n=h[e],a=n.distance,i=n.tile;if(a>p)break;const l=o(i,t,r,s);if(l){const e=l.distance*l.distance;e<p&&(f=l,p=e)}}return f},a=(e,t)=>e.distance-t.distance,i=(e,t,r)=>{const s=e.cached.scene,n=r.length;s.traverse((e=>{Object.getPrototypeOf(e).raycast.call(e,t,r)}));const o=r.length;if(o>n)for(let t=n;t<o;t++)r[t].tile=e},l=new t.Matrix4,c=new t.Ray,d=new t.Vector3,u=[];var h=Object.freeze({UNLOADED:0,LOADING:1,PARSING:2,LOADED:3,FAILED:4});class m extends t.Frustum{constructor(){super(),this.points=new Array(8).fill().map((()=>new t.Vector3))}updateCache(){const{planes:e,points:t}=this;[[e[0],e[3],e[4]],[e[1],e[3],e[4]],[e[0],e[2],e[4]],[e[1],e[2],e[4]],[e[0],e[3],e[5]],[e[1],e[3],e[5]],[e[0],e[2],e[5]],[e[1],e[2],e[5]]].forEach(((e,r)=>{!function(e,t,r,s){const n=f.set(e.normal.x,e.normal.y,e.normal.z,t.normal.x,t.normal.y,t.normal.z,r.normal.x,r.normal.y,r.normal.z);s.set(-e.constant,-t.constant,-r.constant),s.applyMatrix3(n.inverse())}(e[0],e[1],e[2],t[r])}))}}const f=new t.Matrix3;class p{constructor(){this._cameras=[],this._resolution=new t.Vector2,this._infos=[]}add(e){const t=this._cameras;return-1===t.indexOf(e)&&(t.push(e),!0)}remove(e){const t=this._cameras,r=t.indexOf(e);return-1!==r&&(t.splice(r,1),!0)}setResolution(e,t){this._resolution.set(e,t)}updateInfos(e){const r=this._cameras,s=r.length,n=this._infos,o=this._resolution;if(0===s)return void console.warn("CameraList.updateInfos(): No camera added.");for(;n.length>r.length;)n.pop();for(;n.length<r.length;)n.push({frustum:new m,isOrthographic:!1,sseDenominator:-1,position:new t.Vector3,invScale:-1,pixelSize:0});g.copy(e).inverse();const a=b.setFromMatrixColumn(g,0).getLength(),i=b.setFromMatrixColumn(g,1).getLength(),l=b.setFromMatrixColumn(g,2).getLength();Math.abs(Math.max(a-i,a-l))>1e-6&&console.warn("CameraList.updateInfos(): Non uniform scale used for tile which may cause issues when calculating screen space error.");const c=a,d=g;for(let t=0,s=n.length;t<s;t++){const s=r[t],a=n[t],i=o.x*(s.rect.z-s.rect.x),l=o.y*(s.rect.w-s.rect.y);0!==i&&0!==l||console.warn("CameraList.updateInfos(): Resolution for camera error calculation is not set.");const u=s.projectionMatrix.elements;if(a.isOrthographic=1===u[15],a.isOrthographic){const e=2/u[0],t=2/u[5];a.pixelSize=Math.max(t/l,e/i)}else a.sseDenominator=2/u[5]/l;a.invScale=c,_.copy(e).premultiply(s.projectionViewMatrix),a.frustum.setFromMatrix(_),a.frustum.updateCache(),a.position.setFromMatrixPosition(s.worldMatrix).applyMatrix4(d)}}getInfos(){return this._infos}}const g=new t.Matrix4,_=new t.Matrix4,b=new t.Vector3;class A{constructor(e=new t.Box3,r=new t.Matrix3){this.box=e,this.rotation=r}setFromCenterAndAxes(e,t,r,s){T.copy(t),y.copy(r),w.copy(s);const n=T.getLength(),o=y.getLength(),a=w.getLength();T.normalize(),y.normalize(),w.normalize(),0===n&&T.crossVectors(y,w),0===o&&y.crossVectors(T,w),0===a&&w.crossVectors(T,y),this.rotation.set(T.x,y.x,w.x,T.y,y.y,w.y,T.z,y.z,w.z);const i=T.set(n,o,a);return this.box.min.copy(e).sub(i),this.box.max.copy(e).add(i),this}applyMatrix4(e){const t=e.elements;let r=T.set(t[0],t[1],t[2]).getLength();const s=T.set(t[4],t[5],t[6]).getLength(),n=T.set(t[8],t[9],t[10]).getLength();e.determinant()<0&&(r=-r),L.setFromMatrix4(e);const o=1/r,a=1/s,i=1/n;L.elements[0]*=o,L.elements[1]*=o,L.elements[2]*=o,L.elements[3]*=a,L.elements[4]*=a,L.elements[5]*=a,L.elements[6]*=i,L.elements[7]*=i,L.elements[8]*=i,this.rotation.multiply(L);const l=this.box.getCenter(T),c=this.box.getSize(y).multiplyScalar(.5);return c.x*=r,c.y*=s,c.z*=n,l.applyMatrix4(e),this.box.min.copy(l).sub(c),this.box.max.copy(l).add(c),this}getPoints(e){const t=this.box.getCenter(T),r=y.subVectors(this.box.min,t),s=w.subVectors(this.box.max,t);let n=0;for(let o=-1;o<=1;o+=2)for(let a=-1;a<=1;a+=2)for(let i=-1;i<=1;i+=2)e[n].set(o<0?r.x:s.x,a<0?r.y:s.y,i<0?r.z:s.z).applyMatrix3(this.rotation).add(t),n++;return e}getPlanes(e){const t=this.box.getCenter(T),r=y.subVectors(this.box.min,t).applyMatrix3(this.rotation).add(t),s=w.subVectors(this.box.max,t).applyMatrix3(this.rotation).add(t);return T.set(0,0,1).applyMatrix3(this.rotation).normalize(),e[0].setFromNormalAndCoplanarPoint(T,r),e[1].setFromNormalAndCoplanarPoint(T,s),e[1].normal.negate(),e[1].constant*=-1,T.set(0,1,0).applyMatrix3(this.rotation).normalize(),e[2].setFromNormalAndCoplanarPoint(T,r),e[3].setFromNormalAndCoplanarPoint(T,s),e[3].normal.negate(),e[3].constant*=-1,T.set(1,0,0).applyMatrix3(this.rotation).normalize(),e[4].setFromNormalAndCoplanarPoint(T,r),e[5].setFromNormalAndCoplanarPoint(T,s),e[5].normal.negate(),e[5].constant*=-1,e}containsPoint(e){const t=O(this,S),r=T.subVectors(e,t.c);return Math.abs(r.dot(t.u[0]))<=t.e[0]&&Math.abs(r.dot(t.u[1]))<=t.e[1]&&Math.abs(r.dot(t.u[2]))<=t.e[2]}clampPoint(e,t){const r=O(this,S),s=T.subVectors(e,r.c);t.copy(r.c);const n=Math.max(Math.min(s.dot(r.u[0]),r.e[0]),-r.e[0]);t.add(r.u[0].multiplyScalar(n));const o=Math.max(Math.min(s.dot(r.u[1]),r.e[1]),-r.e[1]);t.add(r.u[1].multiplyScalar(o));const a=Math.max(Math.min(s.dot(r.u[2]),r.e[2]),-r.e[2]);return t.add(r.u[2].multiplyScalar(a)),t}intersectsSphere(e){return this.clampPoint(e.center,x),x.distanceToSquared(e.center)<=e.radius*e.radius}intersectsOBB(e,t=Number.EPSILON){O(this,S),O(e,C);for(let e=0;e<3;e++)for(let t=0;t<3;t++)E[e][t]=S.u[e].dot(C.u[t]);const r=T.subVectors(C.c,S.c);M[0]=r.dot(S.u[0]),M[1]=r.dot(S.u[1]),M[2]=r.dot(S.u[2]);for(let e=0;e<3;e++)for(let r=0;r<3;r++)v[e][r]=Math.abs(E[e][r])+t;let s,n;for(let e=0;e<3;e++)if(s=S.e[e],n=C.e[0]*v[e][0]+C.e[1]*v[e][1]+C.e[2]*v[e][2],Math.abs(M[e])>s+n)return!1;for(let e=0;e<3;e++)if(s=S.e[0]*v[0][e]+S.e[1]*v[1][e]+S.e[2]*v[2][e],n=C.e[e],Math.abs(M[0]*E[0][e]+M[1]*E[1][e]+M[2]*E[2][e])>s+n)return!1;return s=S.e[1]*v[2][0]+S.e[2]*v[1][0],n=C.e[1]*v[0][2]+C.e[2]*v[0][1],!(Math.abs(M[2]*E[1][0]-M[1]*E[2][0])>s+n)&&(s=S.e[1]*v[2][1]+S.e[2]*v[1][1],n=C.e[0]*v[0][2]+C.e[2]*v[0][0],!(Math.abs(M[2]*E[1][1]-M[1]*E[2][1])>s+n)&&(s=S.e[1]*v[2][2]+S.e[2]*v[1][2],n=C.e[0]*v[0][1]+C.e[1]*v[0][0],!(Math.abs(M[2]*E[1][2]-M[1]*E[2][2])>s+n)&&(s=S.e[0]*v[2][0]+S.e[2]*v[0][0],n=C.e[1]*v[1][2]+C.e[2]*v[1][1],!(Math.abs(M[0]*E[2][0]-M[2]*E[0][0])>s+n)&&(s=S.e[0]*v[2][1]+S.e[2]*v[0][1],n=C.e[0]*v[1][2]+C.e[2]*v[1][0],!(Math.abs(M[0]*E[2][1]-M[2]*E[0][1])>s+n)&&(s=S.e[0]*v[2][2]+S.e[2]*v[0][2],n=C.e[0]*v[1][1]+C.e[1]*v[1][0],!(Math.abs(M[0]*E[2][2]-M[2]*E[0][2])>s+n)&&(s=S.e[0]*v[1][0]+S.e[1]*v[0][0],n=C.e[1]*v[2][2]+C.e[2]*v[2][1],!(Math.abs(M[1]*E[0][0]-M[0]*E[1][0])>s+n)&&(s=S.e[0]*v[1][1]+S.e[1]*v[0][1],n=C.e[0]*v[2][2]+C.e[2]*v[2][0],!(Math.abs(M[1]*E[0][1]-M[0]*E[1][1])>s+n)&&(s=S.e[0]*v[1][2]+S.e[1]*v[0][2],n=C.e[0]*v[2][1]+C.e[1]*v[2][0],!(Math.abs(M[1]*E[0][2]-M[0]*E[1][2])>s+n)))))))))}toBoundingBoxWithTransform(e,t){const r=this.box.getCenter(T);e.min.copy(this.box.min).sub(r),e.max.copy(this.box.max).sub(r);const s=this.rotation.elements;t.set(s[0],s[3],s[6],r.x,s[1],s[4],s[7],r.y,s[2],s[5],s[8],r.z,0,0,0,1)}}const x=new t.Vector3,T=new t.Vector3,y=new t.Vector3,w=new t.Vector3,L=new t.Matrix3,E=[[],[],[]],v=[[],[],[]],M=[],R=new t.Vector3,S={c:new t.Vector3,u:[new t.Vector3,new t.Vector3,new t.Vector3],e:[]},C={c:new t.Vector3,u:[new t.Vector3,new t.Vector3,new t.Vector3],e:[]};function O(e,t){e.box.getCenter(t.c);const r=e.rotation.elements;return t.u[0].fromArray(r,0),t.u[1].fromArray(r,3),t.u[2].fromArray(r,6),e.box.getSize(R).multiplyScalar(.5).toArray(t.e),t}class I extends A{constructor(){super(),this._points=new Array(8).fill().map((()=>new t.Vector3)),this._planes=new Array(6).fill().map((()=>new t.Plane)),this._originBox=new t.Box3,this._originBoxTransform=new t.Matrix4,this._originBoxTransformInverse=new t.Matrix4}updateCache(){this.getPoints(this._points),this.getPlanes(this._planes),this.toBoundingBoxWithTransform(this._originBox,this._originBoxTransform),this._originBoxTransformInverse.copy(this._originBoxTransform).inverse()}containsPoint(e){return B.copy(e).applyMatrix4(this._originBoxTransformInverse),this.box.containsPoint(B)}intersectsRay(e){return N.copy(e).applyMatrix4(this._originBoxTransformInverse),N.intersectsBox(this._originBox)}intersectRay(e,t){return N.copy(e).applyMatrix4(this._originBoxTransformInverse),N.intersectBox(this._originBox,t)?t.applyMatrix4(this._originBoxTransform):null}intersectsFrustum(e){for(let t=0;t<6;t++){const r=e.planes[t];let s=-1/0;for(let e=0;e<8;e++){const t=this._points[e],n=r.distanceToPoint(t);s=s<n?n:s}if(s<0)return!1}for(let t=0;t<6;t++){const r=this._planes[t];let s=-1/0;for(let t=0;t<8;t++){const n=e.points[t],o=r.distanceToPoint(n);s=s<o?o:s}if(s<0)return!1}return!0}distanceToPoint(e){return B.copy(e).applyMatrix4(this._originBoxTransformInverse),this._originBox.distanceToPoint(B)}getBoundingSphere(e){return this.box.getBoundingSphere(e)}getBoundingBox(e){return e.setFromPoints(this._points)}}const N=new t.Ray,B=new t.Vector3;class P{constructor(e=new t.Vector3(1,1,1)){this.radius=e}getCartographicToPosition(e,t,r,s){this.getCartographicToNormal(e,t,D);const n=this.radius;U.copy(D),U.x*=n.x**2,U.y*=n.y**2,U.z*=n.z**2;const o=Math.sqrt(D.dot(U));return U.multiplyScalar(1/o),s.copy(U).addScaledVector(D,r)}getCartographicToNormal(e,t,r){return F.set(1,-e+Math.PI/2,t),r.setFromSpherical(F).normalize(),function(e){const{x:t,y:r,z:s}=e;e.x=s,e.y=t,e.z=r}(r),r}}const D=new t.Vector3,F=new t.Spherical,U=new t.Vector3;class V extends P{constructor(e=new t.Vector3(1,1,1),r=new t.Vector2(-H,H),s=new t.Vector2(0,2*j),n=new t.Vector2(0,1)){super(e),this.latRange=r,this.lonRange=s,this.heightRange=n}getOrientedBoundingBox(e){Y();const{latRange:t,lonRange:r}=this;if(t.y-t.x<j/2){const e=K(.5,0,1,t.x,t.y),s=K(.5,0,1,r.x,r.y);this.getCartographicToNormal(e,s,z),k.set(0,0,1),G.crossVectors(k,z),k.crossVectors(G,z)}else G.set(1,0,0),k.set(0,1,0),z.set(0,0,1);e.rotation.set(G.x,k.x,z.x,G.y,k.y,z.y,G.z,k.z,z.z),X.setFromMatrix3(e.rotation).inverse();const s=this._getPoints(!0);$.set(0,0,0);for(let e=0,t=s.length;e<t;e++)$.add(s[e]);$.multiplyScalar(1/s.length);for(let e=0,t=s.length;e<t;e++)s[e].sub($).applyMatrix4(X).add($);e.box.makeEmpty(),e.box.setFromPoints(s)}getBoundingSphere(e){Y();const t=this._getPoints(!0);e.makeEmpty(),e.setFromPoints(t)}_getPoints(e=!1){const{latRange:t,lonRange:r,heightRange:s}=this,n=K(.5,0,1,t.x,t.y),o=K(.5,0,1,r.x,r.y),a=Math.floor(r.x/H)*H,i=[[-j/2,0],[j/2,0],[0,a],[0,a+j/2],[0,a+j],[0,a+3*j/2],[t.x,r.y],[t.y,r.y],[t.x,r.x],[t.y,r.x],[0,r.x],[0,r.y],[n,o],[t.x,o],[t.y,o],[n,r.x],[n,r.y]],l=[],c=i.length;for(let n=0;n<=1;n++){const o=K(n,0,1,s.x,s.y);for(let s=0,n=c;s<n;s++){const[n,a]=i[s];if(n>=t.x&&n<=t.y&&a>=r.x&&a<=r.y){const t=Q(e);l.push(t),this.getCartographicToPosition(n,a,o,t)}}}return l}}const G=new t.Vector3,k=new t.Vector3,z=new t.Vector3,$=new t.Vector3,X=new t.Matrix4,j=Math.PI,H=j/2;function K(e,t,r,s,n){return s+(e-t)*(n-s)/(r-t)}let W=0;const J=[];function Q(e=!1){return e?(J[W]||(J[W]=new t.Vector3),W++,J[W-1]):new t.Vector3}function Y(){W=0}class q{constructor(){this.sphere=null,this.obb=null,this.region=null}setOBBData(e,t){const r=new I;r.setFromCenterAndAxes(se.set(e[0],e[1],e[2]),ee.set(e[3],e[4],e[5]),te.set(e[6],e[7],e[8]),re.set(e[9],e[10],e[11])).applyMatrix4(t),r.updateCache(),this.obb=r}setSphereData(e,r){const s=new t.Sphere;s.center.set(e[0],e[1],e[2]),s.radius=e[3],s.applyMatrix4(r),this.sphere=s}setRegionData(e,r,s,n,o,a){const i=new V(Z.clone(),new t.Vector2(r,n),new t.Vector2(e,s),new t.Vector2(o,a));this.region=i;const l=new I;i.getOrientedBoundingBox(l),l.updateCache(),this.obb=l}intersectsRay(e){const t=this.sphere,r=this.obb;return!(t&&!e.intersectsSphere(t))&&!(r&&!r.intersectsRay(e))}intersectRay(e,t){const r=this.sphere,s=this.obb;let n=-1/0,o=-1/0;r&&e.intersectSphere(r,ee)&&(n=r.containsPoint(e.origin)?0:e.origin.distanceToSquared(ee)),s&&s.intersectRay(e,ee)&&(o=s.containsPoint(e.origin)?0:e.origin.distanceToSquared(ee));const a=Math.max(n,o);return a===-1/0?null:e.at(Math.sqrt(a),t)}distanceToPoint(e){const t=this.sphere,r=this.obb;let s=-1/0,n=-1/0;return t&&(s=Math.max(t.distanceToPoint(e),0)),r&&(n=r.distanceToPoint(e)),s>n?s:n}intersectsFrustum(e){const t=this.sphere;if(t&&!e.intersectsSphere(t))return!1;const r=this.obb;return!(r&&!r.intersectsFrustum(e))&&Boolean(t||r)}getOrientedBoundingBox(e,t){this.obb?(e.copy(this.obb._originBox),t.copy(this.obb._originBoxTransform)):(this.getBoundingBox(e),t.identity())}getBoundingBox(e){return this.sphere?this.sphere.getBoundingBox(e):this.obb.getBoundingBox(e)}getBoundingSphere(e){return this.sphere?e.copy(this.sphere):this.obb.getBoundingSphere(e)}}const Z=new t.Vector3(6378137,6378137,6356752.314245179),ee=new t.Vector3,te=new t.Vector3,re=new t.Vector3,se=new t.Vector3;class ne{constructor({maxSize:e=800,minSize:t=600,unloadPercent:r=.05,unloadPriorityCallback:s=oe}){this.maxSize=e,this.minSize=t,this.unloadPercent=r,this.itemSet=new Map,this.itemList=[],this.usedSet=new Set,this.callbacks=new Map,this.scheduled=!1,this.unloadPriorityCallback=s}isFull(){return this.itemSet.size>=this.maxSize}add(e,t){const r=this.itemSet;if(r.has(e))return!1;if(this.isFull())return!1;const s=this.usedSet,n=this.itemList,o=this.callbacks;return n.push(e),s.add(e),r.set(e,Date.now()),o.set(e,t),!0}remove(e){const t=this.usedSet,r=this.itemSet,s=this.itemList,n=this.callbacks;if(r.has(e)){n.get(e)(e);const o=s.indexOf(e);return s.splice(o,1),t.delete(e),r.delete(e),n.delete(e),!0}return!1}markUsed(e){const t=this.itemSet,r=this.usedSet;return!(!t.has(e)||r.has(e))&&(t.set(e,Date.now()),r.add(e),!0)}markAllUnused(){this.usedSet.clear()}unloadToMinSize(){const e=this.unloadPercent,t=this.minSize,r=this.itemList,s=this.itemSet,n=this.usedSet,o=this.callbacks,a=r.length-n.size,i=r.length-t,l=this.unloadPriorityCallback;if(i<=0||a<=0)return!1;r.sort(((e,t)=>{const r=n.has(e),o=n.has(t);return r&&o?0:r||o?r?1:-1:l(s,t)-l(s,e)}));const c=Math.min(i,a),d=Math.max(t*e,c*e);let u=Math.min(d,a);u=Math.ceil(u);const h=r.splice(0,u);for(let e=0,t=h.length;e<t;e++){const t=h[e];o.get(t)(t),s.delete(t),o.delete(t)}return!0}scheduleUnload(e=!0){if(this.scheduled)return!1;this.scheduled=!0,ae((()=>{this.scheduled=!1,this.unloadToMinSize(),e&&this.markAllUnused()}))}}const oe=(e,t)=>e.get(t),ae=e=>{Promise.resolve().then(e)};class ie{constructor({maxJobs:e=6,autoUpdate:t=!0,priorityCallback:r=le}){this.maxJobs=e,this.autoUpdate=t,this.items=[],this.callbacks=new Map,this.currJobs=0,this.scheduled=!1,this.priorityCallback=r,this._runjobs=()=>{this.tryRunJobs(),this.scheduled=!1}}schedulingCallback(e){requestAnimationFrame(e)}sort(){const e=this.priorityCallback;this.items.sort(e)}add(e,t){return new Promise(((r,s)=>{const n=this.items,o=this.callbacks;n.push(e),o.set(e,((...e)=>t(...e).then(r).catch(s))),this.autoUpdate&&this.scheduleJobRun()}))}remove(e){const t=this.items,r=this.callbacks,s=t.indexOf(e);-1!==s&&(t.splice(s,1),r.delete(e))}tryRunJobs(){this.sort();const e=this.items,t=this.callbacks,r=this.maxJobs;let s=this.currJobs;for(;r>s&&e.length>0;){s++;const r=e.pop(),n=t.get(r);t.delete(r),n(r).then((()=>{this.currJobs--,this.autoUpdate&&this.scheduleJobRun()})).catch((()=>{this.currJobs--,this.autoUpdate&&this.scheduleJobRun()}))}this.currJobs=s}scheduleJobRun(){this.scheduled||(this.schedulingCallback(this._runjobs.bind(this)),this.scheduled=!0)}}const le=()=>{throw new Error("PriorityQueue: PriorityCallback function not defined.")};class ce{constructor(){this.lruCache=new ne({unloadPriorityCallback:de}),this.downloadQueue=new ie({maxJobs:4,priorityCallback:ue}),this.parseQueue=new ie({maxJobs:1,priorityCallback:ue})}fetchTileSet(e,t=null,r={}){return fetch(e,r).then((t=>{if(t.ok)return t.json();throw new Error(`TilesLoader: Failed to load tileset "${e}" with status ${t.status} : ${t.statusText}`)})).then((r=>{const n=r.asset.version,[o,a]=n.split(".").map((e=>parseInt(e)));console.assert(o<=1,"TilesLoader: asset.version is expected to be a 1.x or a compatible version."),1===o&&a>0&&console.warn("TilesLoader: tiles versions at 1.1 or higher have limited support. Some new extensions and features may not be supported.");const i=e.replace(/\/[^/]*\/?$/,"");return s(r.root,((e,t)=>he(e,t,i)),null,t,t?t.__depth:0),r}))}requestTileContents(e,t){if(e.__loadingState!==h.UNLOADED)return;const s=t.stats,n=this.lruCache,o=this.downloadQueue,a=this.parseQueue,i=e.__externalTileSet;n.add(e,(e=>{e.__loadingState===h.LOADING?(e.__loadAbort.abort(),e.__loadAbort=null):i?e.children.length=0:t.$disposeTile(e),e.__loadingState===h.LOADING?s.downloading--:e.__loadingState===h.PARSING&&s.parsing--,e.__loadingState=h.UNLOADED,e.__loadIndex++,o.remove(e),a.remove(e)})),e.__loadIndex++;const l=e.__loadIndex,c=new AbortController,d=c.signal;s.downloading++,e.__loadAbort=c,e.__loadingState=h.LOADING;const u=t=>{e.__loadIndex===l&&("AbortError"!==t.name?(o.remove(e),a.remove(e),e.__loadingState===h.PARSING?s.parsing--:e.__loadingState===h.LOADING&&s.downloading--,s.failed++,e.__loadingState=h.FAILED,"Failed to fetch"!==t.message&&(console.error(`TilesLoader: Failed to load tile at url "${e.content.uri}".`),console.error(t))):n.remove(e))};i?o.add(e,(e=>{if(e.__loadIndex!==l)return Promise.resolve();const r=t.preprocessURL,s=t.fetchOptions,n=r?r(e.content.uri):e.content.uri;return this.fetchTileSet(n,e,Object.assign({signal:d},s))})).then((t=>{e.__loadIndex===l&&(s.downloading--,e.__loadAbort=null,e.__loadingState=h.LOADED,e.children.push(t.root))})).catch(u):o.add(e,(e=>{if(e.__loadIndex!==l)return Promise.resolve();const r=t.preprocessURL,s=t.fetchOptions,n=r?r(e.content.uri):e.content.uri;return fetch(n,Object.assign({signal:d},s))})).then((t=>{if(e.__loadIndex===l){if(t.ok){return"gltf"===r(t.url)?t.json():t.arrayBuffer()}throw new Error(`Failed to load model with error code ${t.status}`)}})).then((n=>{if(e.__loadIndex===l)return s.downloading--,s.parsing++,e.__loadAbort=null,e.__loadingState=h.PARSING,a.add(e,(e=>{if(e.__loadIndex!==l)return Promise.resolve();const s=e.content.uri,o=r(s);return t.$parseTile(n,e,o)}))})).then((()=>{e.__loadIndex===l&&(s.parsing--,e.__loadingState=h.LOADED,e.__wasSetVisible&&t.$setTileVisible(e,!0),e.__wasSetActive&&t.$setTileActive(e,!0))})).catch(u)}}const de=(e,t)=>1/(t.__depthFromRenderedParent+1),ue=(e,t)=>e.__depth!==t.__depth?e.__depth>t.__depth?-1:1:e.__inFrustum!==t.__inFrustum?e.__inFrustum?1:-1:e.__used!==t.__used?e.__used?1:-1:e.__error!==t.__error?e.__error>t.__error?1:-1:e.__distanceFromCamera!==t.__distanceFromCamera?e.__distanceFromCamera>t.__distanceFromCamera?-1:1:0,he=(e,s,n)=>{e.contents&&(e.content=e.contents[0]),e.content&&(!("uri"in e.content)&&"url"in e.content&&(e.content.uri=e.content.url,delete e.content.url),e.content.uri&&(e.content.uri=`${n}/${e.content.uri}`),e.content.boundingVolume&&!("box"in e.content.boundingVolume||"sphere"in e.content.boundingVolume||"region"in e.content.boundingVolume)&&delete e.content.boundingVolume),e.parent=s,e.children=e.children||[];if(e.content&&e.content.uri){const t=r(e.content.uri),s=Boolean(t&&"json"===t.toLowerCase());e.__externalTileSet=s,e.__contentEmpty=s}else e.__externalTileSet=!1,e.__contentEmpty=!0;e.__distanceFromCamera=1/0,e.__error=1/0,e.__inFrustum=!1,e.__isLeaf=!1,e.__usedLastFrame=!1,e.__used=!1,e.__wasSetVisible=!1,e.__visible=!1,e.__childrenWereVisible=!1,e.__allChildrenLoaded=!1,e.__wasSetActive=!1,e.__active=!1,e.__loadingState=h.UNLOADED,e.__loadIndex=0,e.__loadAbort=null,e.__depthFromRenderedParent=-1,null===s?(e.__depth=0,e.refine=e.refine||"REPLACE"):(e.__depth=s.__depth+1,e.refine=e.refine||s.refine);const o=new t.Matrix4;e.transform&&o.fromArray(e.transform),s&&o.premultiply(s.cached.transform);const a=(new t.Matrix4).copy(o).inverse(),i=me.setFromMatrixScale(o),l=Math.max(i.x,i.y,i.z);let c=e.geometricError*l;const d=new q;"box"in e.boundingVolume&&d.setOBBData(e.boundingVolume.box,o),"sphere"in e.boundingVolume&&d.setSphereData(e.boundingVolume.sphere,o),"region"in e.boundingVolume&&(d.setRegionData(...e.boundingVolume.region),c=e.geometricError),e.cached={loadIndex:0,transform:o,transformInverse:a,geometricError:c,boundingVolume:d,active:!1,inFrustum:[],scene:null,geometry:null,material:null,featureTable:null,batchTable:null}},me=new t.Vector3;class fe extends t.Loader{constructor(e){super(e),"undefined"==typeof createImageBitmap&&console.warn("ImageBitmapLoader: createImageBitmap() not supported."),"undefined"==typeof fetch&&console.warn("ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,t,r,s){void 0===e&&(e=""),void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);const n=this,o={};o.credentials="anonymous"===this.crossOrigin?"same-origin":"include",o.headers=this.requestHeader,fetch(e,o).then((function(e){return e.blob()})).then((function(e){return createImageBitmap(e,Object.assign(n.options,{colorSpaceConversion:"none"}))})).then((function(r){t&&t(r),n.manager.itemEnd(e)})).catch((function(t){s&&s(t),n.manager.itemError(e),n.manager.itemEnd(e)})),n.manager.itemStart(e)}}const pe=new RegExp("[\\[\\]\\.:\\/]","g");class ge{constructor(){}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(pe,"")}static extractUrlBase(e){const t=e.split("/");return t.pop(),(t.length<1?".":t.join("/"))+"/"}static resolveURL(e,t){return"string"!=typeof e||""===e?"":/^(https?:)?\/\//i.test(e)||/^data:/i.test(e)||/^blob:/i.test(e)?e:t+e}static decodeText(e){if("undefined"!=typeof TextDecoder)return(new TextDecoder).decode(e);let t="";for(let r=0,s=e.length;r<s;r++)t+=String.fromCharCode(e[r]);try{return decodeURIComponent(escape(t))}catch(e){return t}}static parseGLB(e){const t=1313821514,r=5130562,s=new DataView(e),n={magic:s.getUint32(0,!0),version:s.getUint32(4,!0),length:s.getUint32(8,!0)};if(1179937895!==n.magic)return console.error("Invalid glb magic number. Expected 0x46546C67, found 0x"+n.magic.toString(16)),null;n.version<2&&console.error("GLTFLoader: Legacy binary file detected.");let o=s.getUint32(12,!0),a=s.getUint32(16,!0);if(a!==t)return console.error("Invalid glb chunk type. Expected 0x4E4F534A, found 0x"+a.toString(16)),null;const i=new Uint8Array(e,20,o),l=JSON.parse(ge.decodeText(i)),c=[];let d=20+o;for(;d<n.length;){if(o=s.getUint32(d,!0),a=s.getUint32(d+4,!0),a!==r)return console.error("Invalid glb chunk type. Expected 0x004E4942, found 0x"+a.toString(16)),null;const t=d+8,n=e.slice(t,t+o);c.push(n),d+=o+8}return{gltf:l,buffers:c}}static getNormalizedComponentScale(e){if(e===Int8Array)return 1/127;if(e===Uint8Array)return 1/255;if(e===Int16Array)return 1/32767;if(e===Uint16Array)return 1/65535;throw new Error("Unsupported normalized accessor component type.")}}class _e{static parse(e,t){const{gltf:r,path:s}=e,{nodes:n=[],skins:o=[],meshes:a=[],buffers:i,images:l}=r;if(o.forEach((e=>{const{joints:t=[]}=e;t.forEach((e=>{n[e].isBone=!0}))})),n.forEach((e=>{void 0!==e.mesh&&void 0!==e.skin&&(a[e.mesh].isSkinned=!0)})),t.detailLoadProgress){const r=new Set;i&&i.forEach((e=>{if(!e.uri)return;const t=ge.resolveURL(e.uri,s);r.add(t)})),l&&l.forEach(((e,t)=>{const{uri:n,bufferView:o}=e;let a=n;void 0!==o&&(a="blob<"+t+">"),a=ge.resolveURL(a,s),r.add(a)})),r.forEach((e=>t.manager.itemStart(e))),e.loadItems=r}}}class be{static parse(e){const{gltf:{asset:{version:t}}}=e,r=Number(t);if(!(r>=2&&r<3))throw"Only support gltf 2.x."}}class Ae{static parse(e,t){const{gltf:r,loadItems:s}=e;return null!==e.buffers?null:Promise.all(r.buffers.map((r=>{const n=ge.resolveURL(r.uri,e.path);t.detailLoadProgress&&s.delete(n);const o=t.loadFile(n,"arraybuffer").then((e=>(t.detailLoadProgress&&t.manager.itemEnd(n),e)));return t.detailLoadProgress&&o.catch((()=>t.manager.itemEnd(n))),o}))).then((t=>{e.buffers=t}))}}class xe{static loadBufferView(e,t,r){const s=t[e.buffer];if(!r||!r.supported)throw new Error("GLTFLoader: setMeshoptDecoder must be called before loading compressed files.");const n=e.byteOffset||0,o=e.byteLength||0,a=e.count,i=e.byteStride,l=new Uint8Array(s,n,o);return r.decodeGltfBufferAsync?r.decodeGltfBufferAsync(a,i,l,e.mode,e.filter).then((e=>e.buffer)):r.ready.then((()=>{const t=new ArrayBuffer(a*i);return r.decodeGltfBuffer(new Uint8Array(t),a,i,l,e.mode,e.filter),t}))}}class Te{static parse(e,t){const{buffers:r,gltf:s}=e;if(s.bufferViews)return Promise.all(s.bufferViews.map((e=>{const{buffer:s,byteOffset:n=0,byteLength:o=0}=e;if(e.extensions){const{EXT_meshopt_compression:s}=e.extensions;if(s)return xe.loadBufferView(s,r,t.getMeshoptDecoder())}return r[s].slice(n,n+o)}))).then((t=>{e.bufferViews=t}))}}class ye{static loadTextureData(e,t){return new Promise(((r,s)=>{t.load(e,r,void 0,s)}))}}class we{static parse(e,t){const{gltf:r,bufferViews:s,path:n,loadItems:o}=e;if(r.images)return Promise.all(r.images.map(((e,r)=>{const{uri:a,bufferView:i,mimeType:l,name:c}=e;let d=!1,u=a||"";if(void 0!==i){const e=s[i],t=new Blob([e],{type:l});u=URL.createObjectURL(t),d=!0}const h=ge.resolveURL(u,n);let m;if(t.detailLoadProgress&&o.delete(h),l&&l.includes("ktx2"))m=ye.loadTextureData(h,t.getKTX2Loader()).then((e=>(t.detailLoadProgress&&(d?t.manager.itemEnd(ge.resolveURL("blob<"+r+">",n)):t.manager.itemEnd(h)),e)));else{const e={loader:t,imageUrl:h,imageName:c,isObjectURL:d,sourceUrl:u,index:r,path:n};if(!l||!l.includes("avif")&&!l.includes("webp"))return Le(e);m=function(e){const t=new Promise((t=>{const r=new Image;e.includes("avif")?r.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=":r.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",r.onload=()=>{t(1===r.height)}}));return t}(l).then((t=>{if(t)return Le(e);throw new Error("GLTFLoader: WebP or AVIF required by asset but unsupported.")}))}return t.detailLoadProgress&&m.catch((()=>t.manager.itemEnd(h))),m}))).then((t=>{e.images=t}))}}function Le(e){const{loader:t,imageUrl:r,imageName:s,isObjectURL:n,sourceUrl:o,index:a,path:i}=e;return t.loadImage(r).then((e=>(e.__name=s,!0===n&&URL.revokeObjectURL(o),t.detailLoadProgress&&(n?t.manager.itemEnd(ge.resolveURL("blob<"+a+">",i)):t.manager.itemEnd(r)),e)))}const Ee={POSITION:"a_Position",NORMAL:"a_Normal",TANGENT:"a_Tangent",TEXCOORD_0:"a_Uv",TEXCOORD_1:"a_Uv2",TEXCOORD_2:"a_Uv3",TEXCOORD_3:"a_Uv4",TEXCOORD_4:"a_Uv5",TEXCOORD_5:"a_Uv6",TEXCOORD_6:"a_Uv7",TEXCOORD_7:"a_Uv8",COLOR_0:"a_Color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex",TEXCOORD0:"a_Uv",TEXCOORD:"a_Uv",COLOR0:"a_Color",COLOR:"a_Color",WEIGHT:"skinWeight",JOINT:"skinIndex"},ve="MASK",Me="BLEND",Re={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},Se={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Ce={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},Oe={9728:t.TEXTURE_FILTER.NEAREST,9729:t.TEXTURE_FILTER.LINEAR,9984:t.TEXTURE_FILTER.NEAREST_MIPMAP_NEAREST,9985:t.TEXTURE_FILTER.LINEAR_MIPMAP_NEAREST,9986:t.TEXTURE_FILTER.NEAREST_MIPMAP_LINEAR,9987:t.TEXTURE_FILTER.LINEAR_MIPMAP_LINEAR},Ie={33071:t.TEXTURE_WRAP.CLAMP_TO_EDGE,33648:t.TEXTURE_WRAP.MIRRORED_REPEAT,10497:t.TEXTURE_WRAP.REPEAT},Ne=0,Be=1,Pe=2,De=3,Fe=5,Ue=6;class Ve{static parse(e){const{gltf:r,images:s}=e;if(r.textures)return Promise.all(r.textures.map(((e,n)=>{const{sampler:o,source:a=0,name:i}=e,l=new t.Texture2D;if(e.extensions){const{KHR_texture_basisu:t}=e.extensions;if(t){const e=s[t.source],{image:r,mipmaps:n,type:o,format:a,minFilter:i,magFilter:c,generateMipmaps:d,encoding:u,premultiplyAlpha:h}=e;l.image=r,l.mipmaps=n,l.type=o,l.format=a,l.minFilter=i,l.magFilter=c,l.generateMipmaps=d,l.encoding=u,l.premultiplyAlpha=h}else{if(!Object.values(e.extensions).length||!Object.values(e.extensions)[0].hasOwnProperty("source"))return console.error("GLTFLoader: Couldn't load texture"),null;l.image=s[Object.values(e.extensions)[0].source]}}else l.image=s[a];l.version++,l.name=i||l.image.__name||`texture_${n}`,l.flipY=!1;return function(e,r={}){const{magFilter:s,minFilter:n,wrapS:o,wrapT:a}=r;e.magFilter=Oe[s]||t.TEXTURE_FILTER.LINEAR,e.minFilter=Oe[n]||t.TEXTURE_FILTER.LINEAR_MIPMAP_LINEAR,e.wrapS=Ie[o]||t.TEXTURE_WRAP.REPEAT,e.wrapT=Ie[a]||t.TEXTURE_WRAP.REPEAT}(l,(r.samplers||{})[o]),l}))).then((t=>{e.textures=t}))}}class Ge{static getMaterial(){return new t.BasicMaterial}}class ke{static transform(e,t){let r=0,s=0,n=1,o=1,a=0;void 0!==t.offset&&(r=t.offset[0],s=t.offset[1]),void 0!==t.rotation&&(a=t.rotation),void 0!==t.scale&&(n=t.scale[0],o=t.scale[1]),e.setUvTransform(r,s,n,o,a,0,0),void 0!==t.texCoord&&console.warn("Custom UV sets in KHR_texture_transform extension not yet supported.")}}class ze{static getMaterial(){return new t.PBR2Material}static parseParams(e,r,s){const{diffuseFactor:n,diffuseTexture:o,specularFactor:a,glossinessFactor:i,specularGlossinessTexture:l}=r;Array.isArray(n)&&(e.diffuse.fromArray(n),e.opacity=n[3]||1),o&&(e.diffuseMap=s[o.index],e.diffuseMapCoord=o.texCoord||0,e.diffuseMap&&(e.diffuseMap.encoding=t.TEXEL_ENCODING_TYPE.SRGB),function(e,t,r={}){const s=r.KHR_texture_transform;s&&(e[t]=ke.transform(e[t+"Transform"],s))}(e,"diffuseMap",o.extensions)),e.glossiness=void 0!==i?i:1,Array.isArray(a)&&e.specular.fromArray(a),l&&(e.glossinessMap=s[l.index],e.specularMap=s[l.index])}}class $e{static getMaterial(){return new t.PBRMaterial}static parseParams(e,r,s){const{clearcoatFactor:n,clearcoatTexture:o,clearcoatRoughnessFactor:a,clearcoatRoughnessTexture:i,clearcoatNormalTexture:l}=r;if(n&&(e.clearcoat=n),o&&(e.clearcoatMap=s[o.index]),a&&(e.clearcoatRoughness=a),i&&(e.clearcoatRoughnessMap=s[i.index]),l&&(e.clearcoatNormalMap=s[l.index],l.scale)){const r=l.scale;e.clearcoatNormalScale=new t.Vector2(r,r)}}}function Xe(e,t,r={}){const s=r.KHR_texture_transform;s&&ke.transform(e[t+"Transform"],s)}class je{static parse(e){const{bufferViews:r,gltf:s}=e;if(!s.accessors)return;const n=new Map,o=s.accessors.map((e=>{const{bufferView:o,type:a,componentType:i,count:l,byteOffset:c=0,normalized:d=!1,sparse:u}=e;if(void 0===o&&void 0===u)return null;const h=void 0!==o?r[o]:null,m=void 0!==o?s.bufferViews[o].byteStride:void 0,f=Se[a],p=Ce[i],g=p.BYTES_PER_ELEMENT;let _,b;if(m&&m!==g*f){const e=Math.floor(c/m),r="Buffer:"+o+":"+i+":"+e+":"+l;let s=n.get(r);s||(_=new p(h,e*m,l*m/g),s=new t.Buffer(_,m/g),n.set(r,s)),b=new t.Attribute(s,f,c%m/g,d)}else _=null===h?new p(l*f):new p(h,c,l*f),b=new t.Attribute(new t.Buffer(_,f),f,0,d);if(u){const e=Se.SCALAR,s=Ce[u.indices.componentType],n=u.indices.byteOffset||0,o=u.values.byteOffset||0,a=new s(r[u.indices.bufferView],n,u.count*e),i=new p(r[u.values.bufferView],o,u.count*f);null!==h&&(b=new t.Attribute(b.buffer.clone(),b.size,b.offset,b.normalized));const l=b.buffer;for(let e=0,t=a.length;e<t;e++){const t=a[e];if(l.array[t*b.size]=i[e*f],f>=2&&(l.array[t*b.size+1]=i[e*f+1]),f>=3&&(l.array[t*b.size+2]=i[e*f+2]),f>=4&&(l.array[t*b.size+3]=i[e*f+3]),f>=5)throw new Error("Unsupported itemSize in sparse Attribute.")}}return b}));n.clear(),e.accessors=o}}class He{static getGeometry(e,t,r,s,n){const{bufferView:o,attributes:a}=e;if(!n)throw new Error("GLTFLoader: No DRACOLoader instance provided.");const i={};for(const e in a){i[void 0===Ee[e]?e:Ee[e]]=a[e]}const l={},c={};for(const e in r){const t=Ee[e]||e.toLowerCase();if(void 0!==a[e]){const n=s[r[e]],o=Ce[n.componentType];c[t]=o.name,l[t]=!0===n.normalized}}const d=t[o];return new Promise((function(e){n.decodeDracoFile(d,(function(t){for(const e in t.attributes){const r=t.attributes[e],s=l[e];void 0!==s&&(r.normalized=s)}e(t)}),i,c)}))}}let Ke=class{static parse(e,r){const{gltf:s,accessors:n,materials:o,bufferViews:a}=e;if(!s.meshes)return;const i=new Map,l=new Map,c=[];for(let e=0;e<s.meshes.length;e++){const d=s.meshes[e],u=[];for(let e=0;e<d.primitives.length;e++){const c=d.primitives[e],{extensions:h={},mode:m,material:f}=c,{KHR_draco_mesh_compression:p}=h;let g;const _=Qe(c);l.has(_)?g=l.get(_):(g=p?He.getGeometry(p,a,c.attributes,s.accessors,r.getDRACOLoader()):Promise.resolve(new t.Geometry),g=g.then((e=>(We(e,c,s,n),e))),l.set(_,g));const b=g.then((e=>{const r={mode:m,geometry:e,material:void 0===f?new t.PBRMaterial:o[f],weights:Object.keys(e.morphAttributes).length>0&&d.weights?d.weights.slice(0):void 0,skinned:d.isSkinned};return Je(r,i),r}));u.push(b)}c.push(Promise.all(u))}return i.clear(),l.clear(),Promise.all(c).then((t=>{e.primitives=t}))}};function We(e,t,r,s){const{attributes:n,indices:o,targets:a}=t;for(const t in n){const r=n[t],o=void 0===Ee[t]?t:Ee[t];o in e.attributes||e.addAttribute(o,s[r])}void 0===o||e.index||e.setIndex(s[o]);const{boundingBox:i,boundingSphere:l}=e;if(void 0!==n.POSITION){const t=n.POSITION,s=r.accessors[t];if(s.min&&s.max){if(i.min.fromArray(s.min),i.max.fromArray(s.max),s.normalized){const e=ge.getNormalizedComponentScale(Ce[s.componentType]);i.min.multiplyScalar(e),i.max.multiplyScalar(e)}}else e.computeBoundingBox()}else e.computeBoundingBox();if(i.getCenter(l.center),l.radius=i.min.distanceTo(i.max)/2,a){let t=!1,r=!1;for(let e=0,s=a.length;e<s;e++){const s=a[e];if(void 0!==s.POSITION&&(t=!0),void 0!==s.NORMAL&&(r=!0),t&&r)break}if(t||r){const n=[],o=[];for(let i=0,l=a.length;i<l;i++){const l=a[i];t&&n.push(void 0!==l.POSITION?s[l.POSITION]:e.attributes[Ee.POSITION]),r&&o.push(void 0!==l.NORMAL?s[l.NORMAL]:e.attributes[Ee.NORMAL])}t&&(e.morphAttributes.position=n),r&&(e.morphAttributes.normal=o)}}return e}function Je(e,r){let{geometry:s,material:n,skinned:o,mode:a}=e;const i=void 0!==s.attributes[Ee.TANGENT],l=void 0!==s.attributes[Ee.COLOR_0],c=void 0===s.attributes[Ee.NORMAL],d=o;if(a===Ne){const e="PointsMaterial:"+n.id;let s=r.get(e);s||(s=new t.PointsMaterial,t.Material.prototype.copy.call(s,n),s.diffuse.copy(n.diffuse),s.diffuseMap=n.map,s.drawMode=a,s.acceptLight=!1,r.set(e,s)),n=s}else if(a===Be||a===De||a===Pe){const e="BasicMaterial:"+n.id;let s=r.get(e);s||(s=new t.BasicMaterial,s.envMap=void 0,s.diffuse.copy(n.diffuse),s.diffuseMap=n.diffuseMap,s.drawMode=a,r.set(e,s)),n=s}else a===Fe?(console.warn("TRIANGLE_STRIP will be removed later."),n.drawMode=Fe):a===Ue&&(console.warn("TRIANGLE_FAN will be removed later."),n.drawMode=Ue);if(i||l||c||d){let e="ClonedMaterial:"+n.id+":";i&&(e+="vertex-tangents:"),l&&(3===s.attributes[Ee.COLOR_0].size?e+="vertex-colors-rgb:":4===s.attributes[Ee.COLOR_0].size&&(e+="vertex-colors-rgba:")),c&&(e+="flat-shading:");let o=r.get(e);o||(o=n.clone(),i&&(o.vertexTangents=!0,o.normalMap&&(o.normalScale.y*=-1)),l&&(3===s.attributes[Ee.COLOR_0].size?o.vertexColors=t.VERTEX_COLOR.RGB:4===s.attributes[Ee.COLOR_0].size?o.vertexColors=t.VERTEX_COLOR.RGBA:console.warn("Illegal vertex color size: "+s.attributes[Ee.COLOR_0].size)),c&&(o.shading=t.SHADING_TYPE.FLAT_SHADING)),n=o}e.material=n}function Qe(e){const t=e.extensions&&e.extensions.KHR_draco_mesh_compression;let r;if(r=t?"draco:"+t.bufferView+":"+t.indices+":"+Ye(t.attributes):e.indices+":"+Ye(e.attributes)+":"+e.mode,e.targets)for(let t=0,s=e.targets.length;t<s;t++)r+=":"+Ye(e.targets[t]);return r}function Ye(e){let t="";const r=Object.keys(e).sort();for(let s=0,n=r.length;s<n;s++)t+=r[s]+":"+e[r[s]]+";";return t}class qe{static getLight(e){const{color:r,intensity:s=1,type:n,range:o,spot:a}=e;let i;if("directional"===n)i=new t.DirectionalLight;else if("point"===n)i=new t.PointLight,void 0!==o&&(i.distance=o);else{if("spot"!==n)throw new Error("Unexpected light type: "+n);if(i=new t.SpotLight,void 0!==o&&(i.distance=o),a){const{innerConeAngle:e=0,outerConeAngle:t=Math.PI/4}=a;i.angle=t,i.penumbra=1-e/t}}return r&&i.color.fromArray(r),i.intensity=s,i}}class Ze{static parse(e){const{gltf:{nodes:r,cameras:s,extensions:n}}=e;if(!r)return;const o=[],a=[],i=r.map((r=>{const{matrix:i,translation:l,rotation:c,scale:d,camera:u,mesh:h,extensions:m={}}=r,{KHR_lights_punctual:f}=m;let p=null;if(r.isBone)p=new t.Bone;else if(void 0!==h)p=function(e,r){const{primitives:s}=e,{mesh:n,skin:o}=r,a=s[n].map((e=>{const{geometry:r,material:s,weights:n}=e;let a;return void 0!==o?(a=new t.SkinnedMesh(r,s),r.attributes.skinWeight&&!r.attributes.skinWeight.normalized&&function(e){const t=e.offset,r=e.buffer,s=r.stride;for(let e=0,n=r.count;e<n;e++){et.fromArray(r.array,e*s+t);const n=1/et.getManhattanLength();n!==1/0?et.multiplyScalar(n):et.set(1,0,0,0),et.toArray(r.array,e*s+t)}}(r.attributes.skinWeight)):(a=new t.Mesh(r,s),n&&(a.morphTargetInfluences=n.slice())),a}));if(a.length>1){const e=new t.Object3D;return a.forEach((t=>e.add(t))),e}return a[0]}(e,r);else if(void 0!==u)p=function(e){const{orthographic:r,perspective:s,type:n}=e,o=new t.Camera;if("perspective"==n){const{aspectRatio:e,yfov:t,zfar:r,znear:n}=s;o.setPerspective(t,e||1,n||1,r||2e6)}else if("orthographic"==n){const{xmag:e,ymag:t,zfar:s,znear:n}=r;o.setOrtho(-e,e,-t,t,n||1,s||2e6)}return o}(s[u]),o.push(p);else if(f){const e=f.light,t=n.KHR_lights_punctual.lights;p=qe.getLight(t[e]),a.push(p)}else p=new t.Object3D;if(p.name=r.name||"",p.name&&p.children.length>0)for(let e=0;e<p.children.length;e++)p.children[e].name=p.name+"_"+e;return void 0!==i?(p.matrix.fromArray(i),p.matrix.decompose(p.position,p.quaternion,p.scale)):(void 0!==l&&p.position.fromArray(l),void 0!==c&&p.quaternion.fromArray(c),void 0!==d&&p.scale.fromArray(d)),p}));e.nodes=i,e.cameras=o,e.lights=a}}const et=new t.Vector4;class tt{static parse(e){const{gltf:r,accessors:s,nodes:n}=e,o=r.skins;if(!o)return;const a=o.map((e=>{const{inverseBindMatrices:r,joints:o}=e,a=s[r],i=[],l=[];return o.forEach(((e,r)=>{const s=n[e];if(s){i.push(s);const e=new t.Matrix4;a&&e.fromArray(a.buffer.array,16*r),l.push(e)}else console.warn("Joint "+e+" could not be found.")})),new t.Skeleton(i,l)}));e.skins=a,n.forEach(((e,t)=>{const{skin:s}=r.nodes[t];void 0!==s&&e.traverse((function(e){e.isSkinnedMesh&&e.bind(a[s],e.worldMatrix)}))}))}}class rt{static parse(e){const{gltf:r,nodes:s}=e,n=r.scenes.map((e=>{const{name:n="",nodes:o=[]}=e,a=new t.Object3D;a.name=n;for(let e=0;e<o.length;e++)st(o[e],a,r.nodes,s);return a}));e.roots=n,e.root=n[r.scene||0]}}function st(e,t,r,s){const n=s[e],o=r[e];if(t.add(n),o.children){const e=o.children;for(let t=0,o=e.length;t<o;t++){st(e[t],n,r,s)}}}class nt{static parse(e){const{gltf:r,nodes:s,accessors:n}=e,{animations:o}=r;if(!o)return;const a=o.map(((e,r)=>{const{channels:o,samplers:a,name:i=`animation_${r}`}=e,l=[];let c=0;for(let e=0;e<o.length;e++){const r=o[e],i=a[r.sampler];if(i){const e=r.target,o=void 0!==e.node?e.node:e.id,a=n[i.input],d=n[i.output],u=s[o];if(!u)continue;let h;switch(u.updateMatrix(),u.matrixAutoUpdate=!0,Re[e.path]){case Re.rotation:h=t.QuaternionKeyframeTrack;break;case Re.weights:h=t.NumberKeyframeTrack;break;default:h=t.VectorKeyframeTrack}if(!h)continue;const m=new a.buffer.array.constructor(a.buffer.array),f=new Float32Array(d.buffer.array);if(d.normalized){const e=ge.getNormalizedComponentScale(d.buffer.array.constructor);for(let t=0,r=f.length;t<r;t++)f[t]*=e}const p=[];Re[e.path]===Re.weights?u.traverse((function(e){e.isMesh&&e.morphTargetInfluences&&p.push(e)})):p.push(u);for(let r=0,s=p.length;r<s;r++){const s=ot(i.interpolation,h===t.QuaternionKeyframeTrack),n=new h(p[r],Re[e.path],m,f,s);l.push(n)}const g=m[m.length-1];c<g&&(c=g)}}return new t.KeyframeClip(i,l,c)}));e.animations=a}}function ot(e,r){switch(e){case"STEP":return t.StepInterpolant;case"CUBICSPLINE":return r?t.QuaternionCubicSplineInterpolant:t.CubicSplineInterpolant;default:return r?t.QuaternionLinearInterpolant:t.LinearInterpolant}}let at=0;class it{constructor(){this.id=++at,this.url="",this.path="",this.options=null,this.gltf=null,this.loadItems=null,this.buffers=null,this.bufferViews=null,this.images=null,this.textures=null,this.materials=null,this.accessors=null,this.primitives=null,this.nodes=null,this.cameras=null,this.lights=null,this.skins=null,this.root=null,this.roots=null,this.animations=null}}const lt=[class{static parse(e,t){const{url:r}=e;return t.loadFile(r,"arraybuffer").then((t=>{if("glTF"===ge.decodeText(new Uint8Array(t,0,4))){const r=ge.parseGLB(t);e.gltf=r.gltf,e.buffers=r.buffers}else{const r=ge.decodeText(new Uint8Array(t));e.gltf=JSON.parse(r)}}))}},_e,be,Ae,Te,we,Ve,class{static parse(e){const{gltf:r,textures:s}=e;if(!r.materials)return;const n=[];for(let e=0;e<r.materials.length;e++){const{extensions:o={},pbrMetallicRoughness:a,normalTexture:i,occlusionTexture:l,emissiveTexture:c,emissiveFactor:d,alphaMode:u,alphaCutoff:h,doubleSided:m,name:f=""}=r.materials[e],{KHR_materials_unlit:p,KHR_materials_pbrSpecularGlossiness:g,KHR_materials_clearcoat:_}=o;let b=null;if(p?b=Ge.getMaterial():g?(b=ze.getMaterial(),ze.parseParams(b,g,s)):_?(b=$e.getMaterial(),$e.parseParams(b,_,s)):b=new t.PBRMaterial,b.name=f,a){const{baseColorFactor:e,baseColorTexture:r,metallicFactor:n,roughnessFactor:o,metallicRoughnessTexture:i}=a;Array.isArray(e)&&(b.diffuse.fromArray(e),b.opacity=void 0!==e[3]?e[3]:1),r&&(b.diffuseMap=s[r.index],b.diffuseMapCoord=r.texCoord||0,b.diffuseMap&&(b.diffuseMap.encoding=t.TEXEL_ENCODING_TYPE.SRGB,Xe(b,"diffuseMap",r.extensions))),p||g||(b.metalness=void 0!==n?n:1,b.roughness=void 0!==o?o:1,i&&(b.metalnessMap=s[i.index],b.roughnessMap=s[i.index]))}d&&b.emissive.fromArray(d),c&&(b.emissiveMap=s[c.index],b.emissiveMapCoord=c.texCoord||0,b.emissiveMap&&(b.emissiveMap.encoding=t.TEXEL_ENCODING_TYPE.SRGB,Xe(b,"emissiveMap",c.extensions))),l&&(b.aoMap=s[l.index],b.aoMapCoord=l.texCoord||0,void 0!==l.strength&&(b.aoMapIntensity=l.strength),b.aoMap&&Xe(b,"aoMap",l.extensions)),p||i&&(b.normalMap=s[i.index],b.normalScale.set(1,-1),void 0!==i.scale&&b.normalScale.set(i.scale,-i.scale),b.normalMap),b.side=!0===m?t.DRAW_SIDE.DOUBLE:t.DRAW_SIDE.FRONT,u===Me?b.transparent=!0:(b.transparent=!1,u===ve&&(b.alphaTest=void 0!==h?h:.5)),n[e]=b}e.materials=n}},je,Ke,Ze,tt,rt,nt];class ct{constructor(e=t.DefaultLoadingManager,r=lt){this.manager=e,this.detailLoadProgress=!0,this.autoLogError=!0,this._parsers=r.slice(0),this._dracoLoader=null,this._meshoptDecoder=null,this._ktx2Loader=null,this._fileLoader=new t.FileLoader;const s=!0===/^((?!chrome|android).)*safari/i.test(navigator.userAgent),n=navigator.userAgent.indexOf("Firefox")>-1,o=n?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1;"undefined"==typeof createImageBitmap||s||n&&o<98?this._imageLoader=new t.ImageLoader:this._imageLoader=new fe}load(e,t={}){return this.manager.itemStart(e),new Promise(((r,s)=>{const n=new it;n.url=e,n.path=ge.extractUrlBase(e),n.options=t,this._parse(n).then(r).then((()=>this.manager.itemEnd(e))).catch((t=>{this.autoLogError&&console.error(t),this.detailLoadProgress&&n.loadItems&&n.loadItems.forEach((e=>{this.manager.itemEnd(e)})),this.manager.itemError(e),this.manager.itemEnd(e),s(`Error loading glTF model from ${e} .`)}))}))}_parse(e){let t;return new Promise(((r,s)=>{this._parsers.forEach((r=>{t=t?t.then((()=>r.parse(e,this))):r.parse(e,this)})),t?t.then((()=>r(e))).catch(s):r(e)}))}setDRACOLoader(e){return this._dracoLoader=e,this}getDRACOLoader(){return this._dracoLoader}setMeshoptDecoder(e){return this._meshoptDecoder=e,this}getMeshoptDecoder(){return this._meshoptDecoder}setKTX2Loader(e){return this._ktx2Loader=e,this}getKTX2Loader(){return this._ktx2Loader}loadFile(e,t="json"){return this._fileLoader.setResponseType(t),new Promise(((t,r)=>{e=this.manager.resolveURL(e),this._fileLoader.load(e,t,void 0,r)}))}loadImage(e){return new Promise(((t,r)=>{e=this.manager.resolveURL(e),this._imageLoader.load(e,t,void 0,r)}))}insertParser(e,t){this._parsers.splice(t,0,e)}replaceParser(e,t){this._parsers.splice(t,1,e)}}class dt{static parse(e,t){const s=e.options.buffer,n=new DataView(s),o=String.fromCharCode(n.getUint8(0))+String.fromCharCode(n.getUint8(1))+String.fromCharCode(n.getUint8(2))+String.fromCharCode(n.getUint8(3)),a=r(e.url);if(o!==a)throw`Not a ${a} type resource, with url ${e.url}!`;const i=n.getUint32(4,!0);if(1!==i)throw`${a} version must be 1, with url ${e.url}!`;const l=n.getUint32(8,!0);if(l!==s.byteLength)throw`${a} data byte length check failed, with url ${e.url}!`;if("cmpt"===a){const t=n.getUint32(12,!0);return void(e.header={magic:o,version:i,byteLength:l,tilesLength:t})}const c=n.getUint32(12,!0),d=n.getUint32(16,!0),u=n.getUint32(20,!0),h=n.getUint32(24,!0);let m=null;"i3dm"===a&&(m=n.getUint32(28,!0)),e.header={magic:o,version:i,byteLength:l,featureTableJSONByteLength:c,featureTableBinaryByteLength:d,batchTableJSONByteLength:u,batchTableBinaryByteLength:h,gltfFormat:m}}}class ut{constructor(e,t,r,s){this.buffer=e,this.binOffset=t+r,this.binLength=s;let n=null;if(0!==r){const s=new Uint8Array(e,t,r);n=JSON.parse(ge.decodeText(s))}else n={};this.header=n}getKeys(){return Object.keys(this.header)}getData(e,t,r=null,s=null){const n=this.header;if(!(e in n))return null;const o=n[e];if(o instanceof Object){if(Array.isArray(o))return o;{const{buffer:n,binOffset:a,binLength:i}=this,l=o.byteOffset||0,c=o.type||s,d=o.componentType||r;if("type"in o&&s&&o.type!==s)throw new Error("FeatureTable: Specified type does not match expected type.");let u,h;switch(c){case"SCALAR":u=1;break;case"VEC2":u=2;break;case"VEC3":u=3;break;case"VEC4":u=4;break;default:throw new Error(`FeatureTable: Feature type not provided for "${e}".`)}const m=a+l,f=t*u;switch(d){case"BYTE":h=new Int8Array(n,m,f);break;case"UNSIGNED_BYTE":h=new Uint8Array(n,m,f);break;case"SHORT":h=new Int16Array(n,m,f);break;case"UNSIGNED_SHORT":h=new Uint16Array(n,m,f);break;case"INT":h=new Int32Array(n,m,f);break;case"UNSIGNED_INT":h=new Uint32Array(n,m,f);break;case"FLOAT":h=new Float32Array(n,m,f);break;case"DOUBLE":h=new Float64Array(n,m,f);break;default:throw new Error(`FeatureTable: Feature component type not provided for "${e}".`)}if(m+f*h.BYTES_PER_ELEMENT>a+i)throw new Error("FeatureTable: Feature data read outside binary body length.");return h}}return o}}class ht extends ut{constructor(e,t,r,s,n){super(e,r,s,n),this.batchSize=t}getData(e,t=null,r=null){return super.getData(e,this.batchSize,t,r)}}class mt{static parse(e,t){const{header:r,options:s}=e,n=s.buffer,o="i3dm"===r.magic?32:28,a=o+r.featureTableJSONByteLength+r.featureTableBinaryByteLength,i=a,l=i+r.batchTableJSONByteLength+r.batchTableBinaryByteLength,c=n.slice(o,a),d=new ut(c,0,r.featureTableJSONByteLength,r.featureTableBinaryByteLength);let u;if("b3dm"===r.magic)u=d.getData("BATCH_LENGTH");else if("i3dm"===r.magic)u=d.getData("INSTANCES_LENGTH");else{if("pnts"!==r.magic)throw`Unrecognized magic: ${r.magic}!`;u=d.getData("BATCH_LENGTH")||d.getData("POINTS_LENGTH")}const h=n.slice(i,l),m=new ht(h,u,0,r.batchTableJSONByteLength,r.batchTableBinaryByteLength);e.featureTable=d,e.batchTable=m,e.batchTableEnd=l}}class ft{static parse(e,t){const r=new Uint8Array(e.options.buffer,e.batchTableEnd,e.header.byteLength-e.batchTableEnd),s=ge.parseGLB(r.slice().buffer);e.gltf=s.gltf,e.buffers=s.buffers}}let pt=class{static parse(e){const{gltf:r,textures:s}=e;if(!r.materials)return;const n=[];for(let e=0;e<r.materials.length;e++){const{extensions:o={},pbrMetallicRoughness:a,normalTexture:i,occlusionTexture:l,emissiveTexture:c,emissiveFactor:d,alphaMode:u,alphaCutoff:h,doubleSided:m,name:f=""}=r.materials[e],{KHR_materials_unlit:p,KHR_materials_pbrSpecularGlossiness:g,KHR_materials_clearcoat:_,KHR_techniques_webgl:b}=o;let A=null;if(p)A=Ge.getMaterial();else if(g)A=ze.getMaterial(),ze.parseParams(A,g,s);else if(_)A=$e.getMaterial(),$e.parseParams(A,_,s);else if(b){A=new t.PBRMaterial;const{values:e}=b,{u_diffuse:r}=e;r&&(A.diffuseMap=s[r.index],A.diffuseMapCoord=r.texCoord||0)}else A=new t.PBRMaterial;if(A.name=f,a){const{baseColorFactor:e,baseColorTexture:r,metallicFactor:n,roughnessFactor:o,metallicRoughnessTexture:i}=a;Array.isArray(e)&&(A.diffuse.fromArray(e),A.opacity=void 0!==e[3]?e[3]:1),r&&(A.diffuseMap=s[r.index],A.diffuseMapCoord=r.texCoord||0,A.diffuseMap&&(A.diffuseMap.encoding=t.TEXEL_ENCODING_TYPE.SRGB,gt(A,"diffuseMap",r.extensions))),p||g||(A.metalness=void 0!==n?n:1,A.roughness=void 0!==o?o:1,i&&(A.metalnessMap=s[i.index],A.roughnessMap=s[i.index]))}d&&A.emissive.fromArray(d),c&&(A.emissiveMap=s[c.index],A.emissiveMapCoord=c.texCoord||0,A.emissiveMap&&(A.emissiveMap.encoding=t.TEXEL_ENCODING_TYPE.SRGB,gt(A,"emissiveMap",c.extensions))),l&&(A.aoMap=s[l.index],A.aoMapCoord=l.texCoord||0,void 0!==l.strength&&(A.aoMapIntensity=l.strength),A.aoMap&&gt(A,"aoMap",l.extensions)),p||i&&(A.normalMap=s[i.index],A.normalScale.set(1,-1),void 0!==i.scale&&A.normalScale.set(i.scale,-i.scale),A.normalMap),A.side=!0===m?t.DRAW_SIDE.DOUBLE:t.DRAW_SIDE.FRONT,u===Me?A.transparent=!0:(A.transparent=!1,u===ve&&(A.alphaTest=void 0!==h?h:.5)),n[e]=A}e.materials=n}};function gt(e,t,r={}){const s=r.KHR_texture_transform;s&&ke.transform(e[t+"Transform"],s)}class _t{static parse(e,t){const{root:r,featureTable:s,options:n}=e,o=s.getData("RTC_CENTER");o&&(r.position.x+=o[0],r.position.y+=o[1],r.position.z+=o[2]),n.adjustmentTransform&&(r.matrix.transform(r.position,r.scale,r.quaternion),r.matrix.multiply(n.adjustmentTransform),r.matrix.decompose(r.position,r.quaternion,r.scale))}}class bt extends ct{constructor(e){super(e,[dt,mt,ft,_e,be,Ae,Te,we,Ve,pt,je,Ke,Ze,tt,rt,nt,_t])}}class At{static parse(e,t){const r=new Uint8Array(e.options.buffer,e.batchTableEnd,e.header.byteLength-e.batchTableEnd);let s=null;if(1===e.header.gltfFormat)s=Promise.resolve(r);else{const n=ge.resolveURL(ge.decodeText(r),e.path);s=t.loadFile(n,"arraybuffer").then((e=>new Uint8Array(e)))}return s.then((t=>{const r=ge.parseGLB(t.slice().buffer);e.gltf=r.gltf,e.buffers=r.buffers}))}}const xt="\n\t\t#ifdef USE_INSTANCING\n\t\t\t\tattribute mat4 instanceMatrix;\n\t\t#endif\n",Tt="\n\t\t#ifdef USE_INSTANCING\n\t\t\t\ttransformed = (instanceMatrix * vec4(transformed, 1.0)).xyz;\n\t\t#endif\n",yt="\n\t\t#ifdef USE_INSTANCING\n\t\t\t\t#ifdef USE_INSTANCING\n\t\t\t\t\t\tobjectNormal = (transposeMat4(inverseMat4(instanceMatrix)) * vec4(objectNormal, 0.0)).xyz;\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef USE_TANGENT\n\t\t\t\t\t\tobjectTangent = (transposeMat4(inverseMat4(instanceMatrix)) * vec4(objectTangent, 0.0)).xyz;\n\t\t\t\t#endif\n\t\t#endif\n";class wt extends t.PBRMaterial{constructor(){super(),this.type=t.MATERIAL_TYPE.SHADER,this.shaderName="TILE_I_PBR",this.vertexShader=Lt,this.fragmentShader=t.ShaderLib.pbr_frag,this.defines.USE_INSTANCING=!0}}wt.prototype.isInstancedPBRMaterial=!0;let Lt=t.ShaderLib.pbr_vert;Lt=Lt.replace("#include <logdepthbuf_pars_vert>",`\n\t\t#include <logdepthbuf_pars_vert>\n\t\t${xt}\n`),Lt=Lt.replace("#include <pvm_vert>",`\n\t\t${Tt}\n\t\t#include <pvm_vert>\n`),Lt=Lt.replace("#include <normal_vert>",`\n\t\t${yt}\n\t\t#include <normal_vert>\n`);class Et extends t.BasicMaterial{constructor(){super(),this.type=t.MATERIAL_TYPE.SHADER,this.shaderName="TILE_I_BASIC",this.vertexShader=vt,this.fragmentShader=t.ShaderLib.basic_frag,this.defines.USE_INSTANCING=!0}}Et.prototype.isInstancedBasicMaterial=!0;let vt=t.ShaderLib.basic_vert;vt=vt.replace("#include <logdepthbuf_pars_vert>",`\n\t\t#include <logdepthbuf_pars_vert>\n\t\t${xt}\n`),vt=vt.replace("#include <pvm_vert>",`\n\t\t${Tt}\n\t\t#include <pvm_vert>\n`),vt=vt.replace("#include <normal_vert>",`\n\t\t${yt}\n\t\t#include <normal_vert>\n`);class Mt{static parse(e){const{gltf:r,textures:s}=e;if(!r.materials)return;const n=[];for(let e=0;e<r.materials.length;e++){const{extensions:o={},pbrMetallicRoughness:a,normalTexture:i,occlusionTexture:l,emissiveTexture:c,emissiveFactor:d,alphaMode:u,alphaCutoff:h,doubleSided:m,name:f=""}=r.materials[e],{KHR_materials_unlit:p,KHR_materials_pbrSpecularGlossiness:g,KHR_materials_clearcoat:_}=o;let b=null;if(p?b=new Et:g?(b=new wt,b.specular=new t.Color3(1118481),ze.parseParams(b,g,s)):_?(b=new wt,$e.parseParams(b,_,s)):b=new wt,b.name=f,a){const{baseColorFactor:e,baseColorTexture:r,metallicFactor:n,roughnessFactor:o,metallicRoughnessTexture:i}=a;Array.isArray(e)&&(b.diffuse.fromArray(e),b.opacity=void 0!==e[3]?e[3]:1),r&&(b.diffuseMap=s[r.index],b.diffuseMapCoord=r.texCoord||0,b.diffuseMap&&(b.diffuseMap.encoding=t.TEXEL_ENCODING_TYPE.SRGB,Rt(b,"diffuseMap",r.extensions))),p||g||(b.metalness=void 0!==n?n:1,b.roughness=void 0!==o?o:1,i&&(b.metalnessMap=s[i.index],b.roughnessMap=s[i.index]))}d&&b.emissive.fromArray(d),c&&(b.emissiveMap=s[c.index],b.emissiveMapCoord=c.texCoord||0,b.emissiveMap&&(b.emissiveMap.encoding=t.TEXEL_ENCODING_TYPE.SRGB,Rt(b,"emissiveMap",c.extensions))),l&&(b.aoMap=s[l.index],b.aoMapCoord=l.texCoord||0,void 0!==l.strength&&(b.aoMapIntensity=l.strength),b.aoMap&&Rt(b,"aoMap",l.extensions)),p||i&&(b.normalMap=s[i.index],b.normalScale.set(1,-1),void 0!==i.scale&&b.normalScale.set(i.scale,-i.scale),b.normalMap),b.side=!0===m?t.DRAW_SIDE.DOUBLE:t.DRAW_SIDE.FRONT,u===Me?b.transparent=!0:(b.transparent=!1,u===ve&&(b.alphaTest=void 0!==h?h:.5)),n[e]=b}e.materials=n}}function Rt(e,t,r={}){const s=r.KHR_texture_transform;s&&ke.transform(e[t+"Transform"],s)}class St{static parse(e,r){const{gltf:s,accessors:n,materials:o,bufferViews:a}=e;if(!s.meshes)return;const i=new Map,l=new Map,c=[];for(let e=0;e<s.meshes.length;e++){const d=s.meshes[e],u=[];for(let e=0;e<d.primitives.length;e++){const c=d.primitives[e],{extensions:h={},mode:m,material:f}=c,{KHR_draco_mesh_compression:p}=h;let g;const _=It(c);l.has(_)?g=l.get(_):(g=p?He.getGeometry(p,a,c.attributes,s.accessors,r.getDRACOLoader()):Promise.resolve(new t.Geometry),g=g.then((e=>(Ct(e,c,s,n),e))),l.set(_,g));const b=g.then((e=>{const t={mode:m,geometry:e,material:void 0===f?new wt:o[f],weights:Object.keys(e.morphAttributes).length>0&&d.weights?d.weights.slice(0):void 0,skinned:d.isSkinned};return Ot(t,i),t}));u.push(b)}c.push(Promise.all(u))}return i.clear(),l.clear(),Promise.all(c).then((t=>{e.primitives=t}))}}function Ct(e,t,r,s){const{attributes:n,indices:o,targets:a}=t;for(const t in n){const r=n[t],o=void 0===Ee[t]?t:Ee[t];o in e.attributes||e.addAttribute(o,s[r])}void 0===o||e.index||e.setIndex(s[o]);const{boundingBox:i,boundingSphere:l}=e;if(void 0!==n.POSITION){const t=n.POSITION,s=r.accessors[t];if(s.min&&s.max){if(i.min.fromArray(s.min),i.max.fromArray(s.max),s.normalized){const e=ge.getNormalizedComponentScale(Ce[s.componentType]);i.min.multiplyScalar(e),i.max.multiplyScalar(e)}}else e.computeBoundingBox()}else e.computeBoundingBox();if(i.getCenter(l.center),l.radius=i.min.distanceTo(i.max)/2,a){let t=!1,r=!1;for(let e=0,s=a.length;e<s;e++){const s=a[e];if(void 0!==s.POSITION&&(t=!0),void 0!==s.NORMAL&&(r=!0),t&&r)break}if(t||r){const n=[],o=[];for(let i=0,l=a.length;i<l;i++){const l=a[i];t&&n.push(void 0!==l.POSITION?s[l.POSITION]:e.attributes[Ee.POSITION]),r&&o.push(void 0!==l.NORMAL?s[l.NORMAL]:e.attributes[Ee.NORMAL])}t&&(e.morphAttributes.position=n),r&&(e.morphAttributes.normal=o)}}return e}function Ot(e,r){let{geometry:s,material:n,skinned:o,mode:a}=e;const i=void 0!==s.attributes[Ee.TANGENT],l=void 0!==s.attributes[Ee.COLOR_0],c=void 0===s.attributes[Ee.NORMAL],d=o;if(a===Ne){const e="PointsMaterial:"+n.id;let s=r.get(e);s||(s=new t.PointsMaterial,t.Material.prototype.copy.call(s,n),s.diffuse.copy(n.diffuse),s.diffuseMap=n.map,s.drawMode=a,s.acceptLight=!1,r.set(e,s)),n=s}else if(a===Be||a===De||a===Pe){const e="BasicMaterial:"+n.id;let s=r.get(e);s||(s=new t.BasicMaterial,s.envMap=void 0,s.diffuse.copy(n.diffuse),s.diffuseMap=n.diffuseMap,s.drawMode=a,r.set(e,s)),n=s}else a===Fe?(console.warn("TRIANGLE_STRIP will be removed later."),n.drawMode=Fe):a===Ue&&(console.warn("TRIANGLE_FAN will be removed later."),n.drawMode=Ue);if(i||l||c||d){let e="ClonedMaterial:"+n.id+":";i&&(e+="vertex-tangents:"),l&&(3===s.attributes[Ee.COLOR_0].size?e+="vertex-colors-rgb:":4===s.attributes[Ee.COLOR_0].size&&(e+="vertex-colors-rgba:")),c&&(e+="flat-shading:");let o=r.get(e);o||(o=n.clone(),i&&(o.vertexTangents=!0,o.normalMap&&(o.normalScale.y*=-1)),l&&(3===s.attributes[Ee.COLOR_0].size?o.vertexColors=t.VERTEX_COLOR.RGB:4===s.attributes[Ee.COLOR_0].size?o.vertexColors=t.VERTEX_COLOR.RGBA:console.warn("Illegal vertex color size: "+s.attributes[Ee.COLOR_0].size)),c&&(o.shading=t.SHADING_TYPE.FLAT_SHADING)),n=o}e.material=n}function It(e){const t=e.extensions&&e.extensions.KHR_draco_mesh_compression;let r;if(r=t?"draco:"+t.bufferView+":"+t.indices+":"+Nt(t.attributes):e.indices+":"+Nt(e.attributes)+":"+e.mode,e.targets)for(let t=0,s=e.targets.length;t<s;t++)r+=":"+Nt(e.targets[t]);return r}function Nt(e){let t="";const r=Object.keys(e).sort();for(let s=0,n=r.length;s<n;s++)t+=r[s]+":"+e[r[s]]+";";return t}class Bt{static parse(e,r){const{featureTable:s,root:n,options:o}=e,a=s.getData("INSTANCES_LENGTH"),i=s.getData("POSITION",a,"FLOAT","VEC3"),l=s.getData("NORMAL_UP",a,"FLOAT","VEC3"),c=s.getData("NORMAL_RIGHT",a,"FLOAT","VEC3"),d=s.getData("SCALE",a,"FLOAT","SCALAR"),u=s.getData("SCALE_NON_UNIFORM",a,"FLOAT","VEC3");["QUANTIZED_VOLUME_OFFSET","QUANTIZED_VOLUME_SCALE","EAST_NORTH_UP","POSITION_QUANTIZED","NORMAL_UP_OCT32P","NORMAL_RIGHT_OCT32P"].forEach((e=>{e in s.header&&console.warn(`I3DMLoader: Unsupported FeatureTable feature "${e}" detected.`)}));const h=new t.Vector3;for(let e=0;e<a;e++)h.x+=i[3*e+0]/a,h.y+=i[3*e+1]/a,h.z+=i[3*e+2]/a;const m=[];n.traverse((e=>{if(e.isMesh){const{geometry:r}=e;r.instanceCount=a;const s=new t.Attribute(new t.Buffer(new Float32Array(16*a),16),16);s.divisor=1,r.addAttribute("instanceMatrix",s),e.updateMatrix(!0),e.position.copy(h).applyMatrix4(e.worldMatrix),m.push(e)}}));for(let e=0;e<a;e++){Ut.fromArray(i,3*e).sub(h),l?(Dt.fromArray(l,3*e),Ft.fromArray(c,3*e),Pt.crossVectors(Ft,Dt).normalize(),kt.set(Ft.x,Dt.x,Pt.x,0,Ft.y,Dt.y,Pt.y,0,Ft.z,Dt.z,Pt.z,0,0,0,0,1),Vt.setFromRotationMatrix(kt)):Vt.set(0,0,0,1),d?Gt.set(d[e],d[e],d[e]):u?Gt.fromArray(u,3*e):Gt.set(1,1,1),kt.transform(Ut,Gt,Vt).multiply(o.adjustmentTransform);for(let t=0,r=m.length;t<r;t++){const{geometry:r}=m[t],s=r.getAttribute("instanceMatrix").buffer.array;kt.toArray(s,16*e),r.version++}}const f=s.getData("RTC_CENTER");f&&(n.position.x+=f[0],n.position.y+=f[1],n.position.z+=f[2])}}const Pt=new t.Vector3,Dt=new t.Vector3,Ft=new t.Vector3,Ut=new t.Vector3,Vt=new t.Quaternion,Gt=new t.Vector3,kt=new t.Matrix4;class zt extends ct{constructor(e){super(e,[dt,mt,At,_e,be,Ae,Te,we,Ve,Mt,je,St,Ze,tt,rt,nt,Bt])}}class $t{static parse(e,r){const{featureTable:s}=e,n=s.getData("POINTS_LENGTH"),o=s.getData("POSITION",n,"FLOAT","VEC3"),a=s.getData("RGB",n,"UNSIGNED_BYTE","VEC3"),i=s.getData("RGBA",n,"UNSIGNED_BYTE","VEC4");["QUANTIZED_VOLUME_OFFSET","QUANTIZED_VOLUME_SCALE","CONSTANT_RGBA","BATCH_LENGTH","POSITION_QUANTIZED","RGB565","NORMAL","NORMAL_OCT16P","BATCH_ID"].forEach((e=>{e in s.header&&console.warn(`PNTSLoader: Unsupported FeatureTable feature "${e}" detected.`)}));const l=new t.Geometry;l.addAttribute("a_Position",new t.Attribute(new t.Buffer(o,3),3,0,!0)),l.computeBoundingBox(),l.computeBoundingSphere();const c=new t.PointsMaterial;c.size=2,c.sizeAttenuation=!1,null!==a?(l.addAttribute("a_Color",new t.Attribute(new t.Buffer(a,3),3,0,!0)),c.vertexColors=t.VERTEX_COLOR.RGB):null!==i&&(l.addAttribute("a_Color",new t.Attribute(new t.Buffer(i,4),4,0,!0)),c.vertexColors=t.VERTEX_COLOR.RGBA);const d=new t.Mesh(l,c);e.root=d;const u=s.getData("RTC_CENTER");u&&(d.position.x+=u[0],d.position.y+=u[1],d.position.z+=u[2])}}class Xt extends ct{constructor(e){super(e,[dt,mt,$t])}}class jt{static parse(e,t){const r=e.options.buffer,s=e.header.tilesLength,n=[];let o=16;for(let e=0;e<s;e++){const e=new DataView(r,o,12),t=String.fromCharCode(e.getUint8(0))+String.fromCharCode(e.getUint8(1))+String.fromCharCode(e.getUint8(2))+String.fromCharCode(e.getUint8(3)),s=e.getUint32(4,!0),a=e.getUint32(8,!0),i=new Uint8Array(r,o,a);n.push({type:t,buffer:i,version:s}),o+=a}e.tiles=n}}class Ht{static parse(e,r){const{tiles:s,options:n,path:o}=e,a=n.adjustmentTransform,i=[];for(const e in s){const{type:t,buffer:l}=s[e],c={fetchOptions:n.fetchOptions,path:o,buffer:l.slice().buffer};"b3dm"!==t&&"i3dm"!==t||(c.adjustmentTransform=a);const d=r._loaders.get(t);d&&i.push(d.load(`${o}/temp.${t}`,c))}return Promise.all(i).then((e=>{const r=new t.Object3D;return e.forEach((e=>{r.add(e.root)})),{tiles:e,root:r}}))}}class Kt extends ct{constructor(e){super(e,[dt,jt,Ht]);const t=new bt(e),r=new zt(e),s=new Xt(e);this._loaders=new Map([["b3dm",t],["i3dm",r],["pnts",s]])}setDRACOLoader(e){for(const t of this._loaders.values())t.setDRACOLoader(e);return super.setDRACOLoader(e)}setKTX2Loader(e){for(const t of this._loaders.values())t.setKTX2Loader(e);return super.setKTX2Loader(e)}}class Wt{static parse(e,t){const{url:r,options:s}=e,n=s.buffer;if(Jt(r)){const t=ge.parseGLB(n);e.gltf=t.gltf,e.buffers=t.buffers}else e.gltf=n}}const Jt=e=>"glb"===e.substring(e.lastIndexOf(".")+1);class Qt extends ct{constructor(e){super(e),this.replaceParser(Wt,0)}}class Yt{constructor(e){const t=new bt(e),r=new zt(e),s=new Xt(e),n=new Kt(e),o=new Qt(e);this._loaders=new Map([["b3dm",t],["i3dm",r],["pnts",s],["cmpt",n],["gltf",o],["glb",o]])}setDRACOLoader(e){this._loaders.get("b3dm").setDRACOLoader(e),this._loaders.get("i3dm").setDRACOLoader(e),this._loaders.get("cmpt").setDRACOLoader(e),this._loaders.get("gltf").setDRACOLoader(e)}setKTX2Loader(e){this._loaders.get("b3dm").setKTX2Loader(e),this._loaders.get("i3dm").setKTX2Loader(e),this._loaders.get("cmpt").setKTX2Loader(e),this._loaders.get("gltf").setKTX2Loader(e)}loadTileContent(e,t,r,s){t._loadIndex=t._loadIndex||0,t._loadIndex++;const n=t.content.uri,o=n.split(/[\\\/]/g);o.pop();const a=o.join("/"),i=s.fetchOptions,l=t._loadIndex;let c=null;const d=s.rootTileSet.asset&&s.rootTileSet.asset.gltfUpAxis||"y",u=t.cached,h=u.transform;switch(d.toLowerCase()){case"x":qt.makeRotationAxis(er,-Math.PI/2);break;case"y":qt.makeRotationAxis(Zt,Math.PI/2);break;case"z":qt.identity()}const m=this._loaders.get(r);if(m){const t={fetchOptions:i,path:a,buffer:e};"b3dm"!==r&&"i3dm"!==r&&"cmpt"!==r||(t.adjustmentTransform=qt.clone()),c=m.load(n,t)}else console.warn(`TilesRenderer: Content type "${r}" not supported.`),c=Promise.resolve(null);return c.then((e=>{const s=e.root;if(t._loadIndex!==l||!s)return;s.updateMatrix(),"glb"!==r&&"gltf"!==r||s.matrix.multiply(qt),s.matrix.premultiply(h),s.matrix.decompose(s.position,s.quaternion,s.scale),u.scene=s,u.featureTable=e.featureTable,u.batchTable=e.batchTable;const n=[],o=[],a=[];return s.traverse((e=>{if(e.geometry&&o.push(e.geometry),e.material){const t=e.material;n.push(e.material);for(const e in t){const r=t[e];r&&r.isTexture&&a.push(r)}}})),u.materials=n,u.geometry=o,u.textures=a,s}))}}const qt=new t.Matrix4,Zt=new t.Vector3(1,0,0),er=new t.Vector3(0,1,0),tr=(e,t)=>{const r=t.stats,s=t.frameCount,n=t.errorTarget,o=t.maxDepth,a=t.loadSiblings,i=t.$tilesLoader.lruCache,l=t.stopAtEmptyTiles;or(e,s);if(!1===ar(e,t))return!1;if(e.__used=!0,i.markUsed(e),e.__inFrustum=!0,r.inFrustum++,(l||!e.__contentEmpty)&&!e.__externalTileSet){ir(e,t);if(e.__error<=n)return!0;if(o>0&&e.__depth+1>=o)return!0}let c=!1;const d=e.children;for(let e=0,r=d.length;e<r;e++){const r=d[e],s=tr(r,t);c=c||s}if(c&&a)for(let e=0,t=d.length;e<t;e++){const t=d[e];lr(t,s,i)}return!0},rr=(e,t)=>{const r=t.stats,s=t.frameCount;if(!cr(e,s))return;r.used++;const n=e.children;let o=!1;for(let e=0,t=n.length;e<t;e++){const t=n[e];o=o||cr(t,s)}if(o){let r=!1,o=!0;for(let e=0,a=n.length;e<a;e++){const a=n[e];if(rr(a,t),r=r||a.__wasSetVisible||a.__childrenWereVisible,cr(a,s)){const e=a.__allChildrenLoaded||!a.__contentEmpty&&dr(a.__loadingState)||a.__externalTileSet&&a.__loadingState===h.FAILED;o=o&&e}}e.__childrenWereVisible=r,e.__allChildrenLoaded=o}else e.__isLeaf=!0},sr=(e,t)=>{const r=t.stats,s=t.frameCount;if(!cr(e,s))return;const n=e.parent,o=n?n.__depthFromRenderedParent:-1;e.__depthFromRenderedParent=o;const a=t.$tilesLoader.lruCache;if(e.__isLeaf)return e.__depthFromRenderedParent++,void(e.__loadingState===h.LOADED?(e.__inFrustum&&(e.__visible=!0,r.visible++),e.__active=!0,r.active++):a.isFull()||e.__contentEmpty&&!e.__externalTileSet||t.$tilesLoader.requestTileContents(e,t));const i=(t.errorTarget+1)*t.errorThreshold,l=e.__error<=i,c=l||"ADD"===e.refine,d=!e.__contentEmpty,u=d||e.__externalTileSet,m=dr(e.__loadingState)&&u,f=e.__childrenWereVisible,p=e.children,g=e.__allChildrenLoaded;if(c&&d&&e.__depthFromRenderedParent++,c&&!m&&!a.isFull()&&u&&t.$tilesLoader.requestTileContents(e,t),(l&&!g&&!f&&m||"ADD"===e.refine&&m)&&(e.__inFrustum&&(e.__visible=!0,r.visible++),e.__active=!0,r.active++),"ADD"!==e.refine&&l&&!g&&m)for(let r=0,n=p.length;r<n;r++){const n=p[r];cr(n,s)&&!a.isFull()&&(n.__depthFromRenderedParent=e.__depthFromRenderedParent+1,ur(n,n.__depthFromRenderedParent,t))}else for(let e=0,r=p.length;e<r;e++){const r=p[e];cr(r,s)&&sr(r,t)}},nr=(e,t)=>{const r=t.frameCount,s=cr(e,r);if(s||e.__usedLastFrame){let r=!1,n=!1;s&&(r=e.__active,n=t.displayActiveTiles&&e.__active||e.__visible),e.__contentEmpty||e.__loadingState!==h.LOADED||(e.__wasSetActive!==r&&t.$setTileActive(e,r),e.__wasSetVisible!==n&&t.$setTileVisible(e,n)),e.__wasSetActive=r,e.__wasSetVisible=n,e.__usedLastFrame=s;const o=e.children;for(let e=0,r=o.length;e<r;e++){const r=o[e];nr(r,t)}}},or=(e,t)=>{e.__lastFrameVisited!==t&&(e.__lastFrameVisited=t,e.__used=!1,e.__inFrustum=!1,e.__isLeaf=!1,e.__visible=!1,e.__active=!1,e.__error=1/0,e.__distanceFromCamera=1/0,e.__childrenWereVisible=!1,e.__allChildrenLoaded=!1)},ar=(e,t)=>{const r=t.$cameras.getInfos(),s=e.cached,n=s.boundingVolume,o=s.inFrustum;let a=!1;for(let e=0,t=r.length;e<t;e++){const t=r[e].frustum;n.intersectsFrustum(t)?(a=!0,o[e]=!0):o[e]=!1}return a},ir=(e,t)=>{const r=t.$cameras.getInfos(),s=e.cached,n=s.inFrustum,o=s.boundingVolume;let a=-1/0,i=1/0;for(let e=0,t=r.length;e<t;e++){if(!n[e])continue;const t=r[e],l=t.invScale;let c;if(t.isOrthographic){const e=t.pixelSize;c=s.geometricError/(e*l)}else{const e=o.distanceToPoint(t.position)*l,r=t.sseDenominator;c=s.geometricError/(e*r),i=Math.min(i,e)}a=Math.max(a,c)}e.__distanceFromCamera=i,e.__error=a},lr=(e,t,r)=>{if(or(e,t),e.__used=!0,r.markUsed(e),e.__contentEmpty){const s=e.children;for(let e=0,n=s.length;e<n;e++)lr(s[e],t,r)}},cr=(e,t)=>e.__lastFrameVisited===t&&e.__used;function dr(e){return e===h.LOADED||e===h.FAILED}const ur=(e,t,r)=>{if(e.__contentEmpty&&(!e.__externalTileSet||dr(e.__loadingState))){const s=e.children;for(let e=0,n=s.length;e<n;e++){const n=s[e];n.__depthFromRenderedParent=t,ur(n,t,r)}}else r.$tilesLoader.requestTileContents(e,r)};class hr extends t.Object3D{constructor(e,r=new t.LoadingManager){super(),this.fetchOptions={},this.errorTarget=6,this.errorThreshold=1/0,this.loadSiblings=!0,this.displayActiveTiles=!1,this.maxDepth=1/0,this.stopAtEmptyTiles=!0,this.preprocessURL=null,r.setURLModifier((e=>this.preprocessURL?this.preprocessURL(e):e)),this.manager=r,this.stats={parsing:0,downloading:0,failed:0,inFrustum:0,used:0,active:0,visible:0},this.frameCount=0,this.activeTiles=new Set,this.visibleTiles=new Set,this._rootURL=e,this._rootTileSet=null,this._autoDisableRendererCulling=!0,this.$cameras=new p,this.$tilesLoader=new ce,this.$modelLoader=new Yt(r),this.$events=new t.EventDispatcher}get rootURL(){return this._rootURL}get rootTileSet(){const e=this._rootTileSet;if(!e){const e=this._rootURL;return this._rootTileSet=this.$tilesLoader.fetchTileSet(this.preprocessURL?this.preprocessURL(e):e,null,this.fetchOptions).then((e=>{this._rootTileSet=e})).then((t=>{Promise.resolve().then((()=>{fr.json=t,fr.url=e,this.$events.dispatchEvent(fr)}))})).catch((e=>{console.error(e),this._rootTileSet=e})),null}return e instanceof Promise||e instanceof Error?null:e}get root(){const e=this.rootTileSet;return e?e.root:null}get autoDisableRendererCulling(){return this._autoDisableRendererCulling}set autoDisableRendererCulling(e){this._autoDisableRendererCulling!==e&&(super._autoDisableRendererCulling=e,this.traverse((t=>{const r=t.cached.scene;r&&r.traverse((t=>{t.frustumCulled=t[mr]&&!e}))})))}setDRACOLoader(e){this.$modelLoader.setDRACOLoader(e)}setKTX2Loader(e){this.$modelLoader.setKTX2Loader(e)}addEventListener(e,t,r){this.$events.addEventListener(e,t,r)}removeEventListener(e,t,r){this.$events.removeEventListener(e,t,r)}update(){const e=this.root;if(!e)return;const{stats:t}=this;var r,s;t.inFrustum=0,t.used=0,t.active=0,t.visible=0,this.frameCount++,this.$cameras.updateInfos(this.worldMatrix),tr(r=e,s=this),rr(r,s),sr(r,s),nr(r,s),s.$tilesLoader.lruCache.scheduleUnload()}addCamera(e){return this.$cameras.add(e)}removeCamera(e){return this.$cameras.remove(e)}resize(e,t){this.$cameras.setResolution(e,t)}raycast(e,t){if(!this.root)return null;n(this.root,this,e,t),t.sort(a)}raycastFirst(e){return this.root?o(this.root,this,e):null}getBoundingBox(e){if(!this.root)return!1;const t=this.root.cached.boundingVolume;return!!t&&(t.getBoundingBox(e),!0)}getOrientedBoundingBox(e,t){if(!this.root)return!1;const r=this.root.cached.boundingVolume;return!!r&&(r.getOrientedBoundingBox(e,t),!0)}getBoundingSphere(e){if(!this.root)return!1;const t=this.root.cached.boundingVolume;return!!t&&(t.getBoundingSphere(e),!0)}traverse(e,t){const r=this.root;r&&s(r,e,t)}resetFailedTiles(){const e=this.stats;0!==e.failed&&(this.traverse((e=>{e.__loadingState===h.FAILED&&(e.__loadingState=h.UNLOADED)})),e.failed=0)}dispose(){const e=this.$tilesLoader.lruCache;this.traverse((t=>{e.remove(t)})),this.stats={parsing:0,downloading:0,failed:0,inFrustum:0,used:0,active:0,visible:0},this.frameCount=0}updateMatrix(e){if((this.matrixAutoUpdate||this.matrixNeedsUpdate)&&(this.matrix.transform(this.position,this.scale,this.quaternion),this.matrixNeedsUpdate=!1,this.worldMatrixNeedsUpdate=!0),(this.worldMatrixNeedsUpdate||e)&&(null===this.parent?br.copy(this.matrix):br.multiplyMatrices(this.parent.worldMatrix,this.matrix),this.worldMatrixNeedsUpdate=!1,!Ar(br,this.worldMatrix))){this.worldMatrix.copy(br);const e=this.children;for(let t=0,r=e.length;t<r;t++)e[t].updateMatrix()}}$parseTile(e,t,r){return this.$modelLoader.loadTileContent(e,t,r,this).then((e=>{e.traverse((e=>{e[mr]=e.frustumCulled,e.frustumCulled=e.frustumCulled&&!this._autoDisableRendererCulling})),pr.scene=e,pr.tile=t,this.$events.dispatchEvent(pr)}))}$setTileVisible(e,t){const r=e.cached.scene;if(!r)return;const s=this.visibleTiles;t?(this.add(r),s.add(e),r.updateMatrix(!0)):(this.remove(r),s.delete(e)),_r.scene=r,_r.tile=e,_r.visible=t,this.$events.dispatchEvent(_r)}$setTileActive(e,t){const r=this.activeTiles;t?r.add(e):r.delete(e)}$disposeTile(e){const t=e.cached;if(t.scene){const r=t.materials,s=t.geometry,n=t.textures;for(let e=0,t=s.length;e<t;e++)s[e].dispose();for(let e=0,t=r.length;e<t;e++)r[e].dispose();for(let e=0,t=n.length;e<t;e++){n[e].dispose()}gr.scene=t.scene,gr.tile=e,this.$events.dispatchEvent(gr),t.scene=null,t.materials=null,t.textures=null,t.geometry=null}e._loadIndex++}}const mr=Symbol("INITIAL_FRUSTUM_CULLED"),fr={type:"TileSetLoaded",json:null,url:null},pr={type:"TileLoaded",scene:null,tile:null},gr={type:"TileDisposed",scene:null,tile:null},_r={type:"TileVisibilityChanged",scene:null,tile:null,visible:!1},br=new t.Matrix4,Ar=(e,t,r=Number.EPSILON)=>{const s=e.elements,n=t.elements;for(let e=0;e<16;e++)if(Math.abs(s[e]-n[e])>r)return!1;return!0};e.B3DMLoader=bt,e.CMPTLoader=Kt,e.DebugLoadParser=class{static parse(e,t){let s=null;return s="gltf"===r(e.url)?t.loadFile(e.url).then((t=>{e.options.buffer=t})):t.loadFile(e.url,"arraybuffer").then((t=>{e.options.buffer=t})),s}},e.I3DMLoader=zt,e.InstancedBasicMaterial=Et,e.InstancedPBRMaterial=wt,e.OBB=A,e.PNTSLoader=Xt,e.TileGLTFLoader=Qt,e.Tiles3D=hr}));
